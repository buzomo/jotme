<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Daily Notes</title>
    <style>
      ::-webkit-scrollbar {
        display: none;
      }
      .container {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
      }
      .notes-container {
        display: flex;
        width: 100%;
        justify-content: space-between;
        margin-top: 20px;
      }
      .note-area {
        flex: 1;
        margin: 0 10px;
        border: 1px solid #ddd;
        padding: 10px;
        box-sizing: border-box;
      }
      .note-header {
        text-align: center;
        font-weight: bold;
        margin-bottom: 10px;
      }
      .text-box {
        height: 3500px;
      }
      textarea {
        border: none;
        outline: 0;
        box-sizing: border-box;
        width: 100%;
        color: inherit;
        background-color: inherit;
        line-height: 200%;
      }
      a {
        color: rgb(127, 197, 255);
      }
      .markdown-viewer,
      .text-box {
        font-family: "BIZ UDGothic";
        width: 100%;
        margin-top: 20px;
        border: none;
        padding: 5px;
        letter-spacing: 150%;
        font-size: large;
        line-height: 200%;
        word-break: break-all;
      }
      .markdown-viewer {
        display: none;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="notes-container">
        <div class="note-area" id="yesterdayArea">
          <div class="note-header" id="yesterdayHeader">昨日</div>
          <textarea class="text-box" id="yesterdayBox" placeholder="メモを入力してください..."></textarea>
          <div class="markdown-viewer" id="yesterdayViewer"></div>
        </div>
        <div class="note-area" id="todayArea">
          <div class="note-header" id="todayHeader">今日</div>
          <textarea class="text-box" id="todayBox" placeholder="メモを入力してください..."></textarea>
          <div class="markdown-viewer" id="todayViewer"></div>
        </div>
        <div class="note-area" id="tomorrowArea">
          <div class="note-header" id="tomorrowHeader">明日</div>
          <textarea class="text-box" id="tomorrowBox" placeholder="メモを入力してください..."></textarea>
          <div class="markdown-viewer" id="tomorrowViewer"></div>
        </div>
      </div>
    </div>
    <script>
      (() => {
        const elements = {
          yesterdayArea: document.getElementById("yesterdayArea"),
          todayArea: document.getElementById("todayArea"),
          tomorrowArea: document.getElementById("tomorrowArea"),
          yesterdayBox: document.getElementById("yesterdayBox"),
          todayBox: document.getElementById("todayBox"),
          tomorrowBox: document.getElementById("tomorrowBox"),
          yesterdayViewer: document.getElementById("yesterdayViewer"),
          todayViewer: document.getElementById("todayViewer"),
          tomorrowViewer: document.getElementById("tomorrowViewer"),
          yesterdayHeader: document.getElementById("yesterdayHeader"),
          todayHeader: document.getElementById("todayHeader"),
          tomorrowHeader: document.getElementById("tomorrowHeader"),
        };

        const state = {
          today: new Date(),
        };

        // 日付をフォーマットして表示
        const formatDate = (date) => {
          return `${date.getFullYear()}年${String(date.getMonth() + 1).padStart(2, "0")}月${String(date.getDate()).padStart(2, "0")}日 (${date.toLocaleDateString("ja-JP", { weekday: "long" })})`;
        };

        // メモを保存
        const saveMemo = (date, content) => {
          const dateStr = date.toISOString().split("T")[0];
          localStorage.setItem(dateStr, content);
        };

        // メモを読み込み
        const loadMemo = (date, box, viewer) => {
          const dateStr = date.toISOString().split("T")[0];
          const content = localStorage.getItem(dateStr) || "";
          box.value = content;
          viewer.innerHTML = marked.parse(content);
          viewer.style.display = content ? "block" : "none";
          box.style.display = content ? "none" : "block";
        };

        // 日付ごとのメモを更新
        const updateMemo = () => {
          const yesterday = new Date(state.today);
          yesterday.setDate(yesterday.getDate() - 1);
          const tomorrow = new Date(state.today);
          tomorrow.setDate(tomorrow.getDate() + 1);

          elements.yesterdayHeader.textContent = formatDate(yesterday);
          elements.todayHeader.textContent = formatDate(state.today);
          elements.tomorrowHeader.textContent = formatDate(tomorrow);

          loadMemo(yesterday, elements.yesterdayBox, elements.yesterdayViewer);
          loadMemo(state.today, elements.todayBox, elements.todayViewer);
          loadMemo(tomorrow, elements.tomorrowBox, elements.tomorrowViewer);
        };

        // テキストボックスとビューアの表示を切り替え
        const toggleEditView = (box, viewer, isEdit) => {
          box.style.display = isEdit ? "block" : "none";
          viewer.style.display = isEdit ? "none" : "block";
        };

        // 初期化
        const init = () => {
          updateMemo();
        };

        // ビューアをクリックで編集モードに
        elements.yesterdayViewer.addEventListener("click", () => {
          toggleEditView(elements.yesterdayBox, elements.yesterdayViewer, true);
          elements.yesterdayBox.focus();
        });

        elements.todayViewer.addEventListener("click", () => {
          toggleEditView(elements.todayBox, elements.todayViewer, true);
          elements.todayBox.focus();
        });

        elements.tomorrowViewer.addEventListener("click", () => {
          toggleEditView(elements.tomorrowBox, elements.tomorrowViewer, true);
          elements.tomorrowBox.focus();
        });

        // テキストボックスのフォーカスアウトイベント
        elements.yesterdayBox.addEventListener("blur", () => {
          const yesterday = new Date(state.today);
          yesterday.setDate(yesterday.getDate() - 1);
          saveMemo(yesterday, elements.yesterdayBox.value);
          elements.yesterdayViewer.innerHTML = marked.parse(elements.yesterdayBox.value);
          toggleEditView(elements.yesterdayBox, elements.yesterdayViewer, false);
        });

        elements.todayBox.addEventListener("blur", () => {
          saveMemo(state.today, elements.todayBox.value);
          elements.todayViewer.innerHTML = marked.parse(elements.todayBox.value);
          toggleEditView(elements.todayBox, elements.todayViewer, false);
        });

        elements.tomorrowBox.addEventListener("blur", () => {
          const tomorrow = new Date(state.today);
          tomorrow.setDate(tomorrow.getDate() + 1);
          saveMemo(tomorrow, elements.tomorrowBox.value);
          elements.tomorrowViewer.innerHTML = marked.parse(elements.tomorrowBox.value);
          toggleEditView(elements.tomorrowBox, elements.tomorrowViewer, false);
        });

        // テキストボックスのキーダウンイベント（リスト・見出し補完）
        const setupTextBoxKeyDown = (box) => {
          box.addEventListener("keydown", (e) => {
            const t = box.selectionStart;
            const a = box.value.substring(0, t);
            const l = a.split("\n");
            const n = l.length - 1;
            const o = l[n];
            const r = o.match(/^(\s*)- /);

            if ("Tab" === e.key) {
              e.preventDefault();
              const t = box.selectionStart;
              const a = box.selectionEnd;
              const l = box.value.slice(0, t);
              const n = box.value.slice(t, a);
              const o = box.value.slice(a);
              const r = l.lastIndexOf("\n") + 1;
              const c = a + o.indexOf("\n");
              const i = box.value.slice(r, c).split("\n");

              if (e.shiftKey) {
                const e = i.map((e) => e.startsWith("  ") ? e.slice(2) : e).join("\n");
                box.value = box.value.slice(0, r) + e + box.value.slice(c);
                const a = t - 2 * i.filter((e) => e.startsWith("  ")).length;
                box.selectionStart = a;
                box.selectionEnd = a;
              } else {
                const e = i.map((e) => "  " + e).join("\n");
                box.value = box.value.slice(0, r) + e + box.value.slice(c);
                const a = t + 2 * i.length;
                box.selectionStart = a;
                box.selectionEnd = a;
              }
            }

            if ("Enter" === e.key) {
              if (r) {
                e.preventDefault();
                const n = r[1];
                const c = box.value.substring(t);
                if ("-" === o.trim()) {
                  l.pop();
                  const e = l.join("\n") + "\n" + c;
                  box.value = e;
                  box.selectionStart = box.selectionEnd = t - o.length + 1;
                } else {
                  const e = a + "\n" + n + "- " + c;
                  box.value = e;
                  box.selectionStart = box.selectionEnd = t + n.length + 3;
                }
              } else {
                const c = o.match(/^#\s/);
                if (c && o.trim().length > 2) {
                  e.preventDefault();
                  const l = a + "\n- " + box.value.substring(t);
                  box.value = l;
                  box.selectionStart = box.selectionEnd = t + 4;
                } else if (n > 1) {
                  e.preventDefault();
                  const l = a + "\n\n# " + box.value.substring(t);
                  box.value = l;
                  box.selectionStart = box.selectionEnd = t + 6;
                }
              }
            } else if ("Backspace" === e.key) {
              if ("-" === o.trim()) {
                e.preventDefault();
                l.pop();
                const a = l.join("\n") + box.value.substring(t);
                box.value = a;
                box.selectionStart = box.selectionEnd = t - o.length;
              }
            } else if ("#" === e.key && "" === o) {
              e.preventDefault();
              const l = a + "# " + box.value.substring(t);
              box.value = l;
              box.selectionStart = box.selectionEnd = t + 2;
            }
          });
        };

        // 各テキストボックスにキーダウンイベントを設定
        setupTextBoxKeyDown(elements.yesterdayBox);
        setupTextBoxKeyDown(elements.todayBox);
        setupTextBoxKeyDown(elements.tomorrowBox);

        // 初期化
        init();
      })();
    </script>
  </body>
</html>
